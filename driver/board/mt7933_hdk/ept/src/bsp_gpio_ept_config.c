/* Copyright Statement:
 *
 * (C) 2005-2016  MediaTek Inc. All rights reserved.
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
 * Without the prior written permission of MediaTek and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
 * if you have agreed to and been bound by the applicable license agreement with
 * MediaTek ("License Agreement") and been granted explicit permission to do so within
 * the License Agreement ("Permitted User").  If you are not a Permitted User,
 * please cease any access or use of MediaTek Software immediately.
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
 * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
 * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 */

#include "bsp_gpio_ept_config.h"
#include "mt7933.h"
#include "ept_gpio_drv.h"
#include "hal_gpio_internal.h"
#include "hal_gpio.h"

GPIO_BASE_REGISTER_T *ept_gpio_base = (GPIO_BASE_REGISTER_T *)(GPIO_BASE_BASE);
GPIO_CFG0_REGISTER_T *ept_gpio_cfg0 = (GPIO_CFG0_REGISTER_T *)(CHIP_PINMUX_BASE);

#define GPIO_MODE_MASK_BIT     0xF

/* joint together the MACROs generated by EPT to 32-bits data as a result of the GPIO register is 32-bit,
   the data will be written to corresponding register after jointed.
*/
#define GPIO_HWORD_REG_VAL(name, port0, port1, port2, port3, port4, port5, port6, port7, port8, port9, port10, \
                                port11, port12, port13, port14, port15, port16, port17, port18, port19, port20, port21, \
                               port22, port23, port24, port25, port26, port27, port28, port29, port30, port31,      \
                               port32, port33, port34, port35, port36, port37, port38, port39, port40, port41,      \
                               port42, port43, port44, port45, port46, port47, port48, port49, port50, port51, port52)      \
((GPIO_PORT##port0##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*0) & 0x1f)) | \
(GPIO_PORT##port1##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*1) & 0x1f)) |    \
(GPIO_PORT##port2##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*2) & 0x1f)) |   \
(GPIO_PORT##port3##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*3) & 0x1f)) |    \
(GPIO_PORT##port4##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*4) & 0x1f)) | \
(GPIO_PORT##port5##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*5) & 0x1f)) |    \
(GPIO_PORT##port6##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*6) & 0x1f)) | \
(GPIO_PORT##port7##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*7) & 0x1f)) |    \
(GPIO_PORT##port8##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*8) & 0x1f)) | \
(GPIO_PORT##port9##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*9) & 0x1f)) |    \
(GPIO_PORT##port10##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*10) & 0x1f)) |\
(GPIO_PORT##port11##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*11) & 0x1f)) |  \
(GPIO_PORT##port12##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*12) & 0x1f)) | \
(GPIO_PORT##port13##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*13) & 0x1f)) |  \
(GPIO_PORT##port14##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*14) & 0x1f)) | \
(GPIO_PORT##port15##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*15) & 0x1f)) |  \
(GPIO_PORT##port16##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*16) & 0x1f)) | \
(GPIO_PORT##port17##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*17) & 0x1f)) |  \
(GPIO_PORT##port18##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*18) & 0x1f)) |  \
(GPIO_PORT##port19##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*19) & 0x1f)) |  \
(GPIO_PORT##port20##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*20) & 0x1f)) | \
(GPIO_PORT##port21##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*21) & 0x1f)) |  \
(GPIO_PORT##port22##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*22) & 0x1f)) | \
(GPIO_PORT##port23##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*23) & 0x1f)) |  \
(GPIO_PORT##port24##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*24) & 0x1f)) | \
(GPIO_PORT##port25##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*25) & 0x1f)) |  \
(GPIO_PORT##port26##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*26) & 0x1f)) |  \
(GPIO_PORT##port27##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*27) & 0x1f)) |  \
(GPIO_PORT##port28##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*28) & 0x1f)) | \
(GPIO_PORT##port29##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*29) & 0x1f)) |  \
(GPIO_PORT##port30##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*30) & 0x1f)) | \
(GPIO_PORT##port31##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*31) & 0x1f)) | \
(GPIO_PORT##port32##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*32) & 0x1f)) |    \
(GPIO_PORT##port33##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*33) & 0x1f)) |   \
(GPIO_PORT##port34##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*34) & 0x1f)) |    \
(GPIO_PORT##port35##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*35) & 0x1f)) | \
(GPIO_PORT##port36##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*36) & 0x1f)) |    \
(GPIO_PORT##port37##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*37) & 0x1f)) | \
(GPIO_PORT##port38##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*38) & 0x1f)) |    \
(GPIO_PORT##port39##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*39) & 0x1f)) | \
(GPIO_PORT##port40##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*40) & 0x1f)) |    \
(GPIO_PORT##port41##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*41) & 0x1f)) |\
(GPIO_PORT##port42##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*42) & 0x1f)) |  \
(GPIO_PORT##port43##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*43) & 0x1f)) | \
(GPIO_PORT##port44##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*44) & 0x1f)) |  \
(GPIO_PORT##port45##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*45) & 0x1f)) | \
(GPIO_PORT##port46##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*46) & 0x1f)) |  \
(GPIO_PORT##port47##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*47) & 0x1f)) | \
(GPIO_PORT##port48##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*48) & 0x1f)) |  \
(GPIO_PORT##port49##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*49) & 0x1f)) |  \
(GPIO_PORT##port50##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*50) & 0x1f)) |  \
(GPIO_PORT##port51##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*51) & 0x1f)) | \
(GPIO_PORT##port52##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*52) & 0x1f)))


const uint32_t GPIO_REG_PIN_MASK[8] = {0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0, 0, 0, 0};

/**
  * @brief  write the joint data about GPIO mode to GPIO mode register one by one
  * @param  None
  * @retval None
  */
void gpio_mode_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_MODE_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_MODE_REG_MAX_NUM
    uint32_t mode_temp[GPIO_MODE_REG_MAX_NUM] = { GPIO_MODE_ALL_VALUE };

    for (i = 0; i < GPIO_MODE_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;
        for (j = 0; j < GPIO_MODE_ONE_REG_CONTROL_NUM; j++) {
            temp = j + i * GPIO_MODE_ONE_REG_CONTROL_NUM;
            if ((1 << (temp % 32)) &  GPIO_REG_PIN_MASK[temp / 32]) {
                uint32_t pin_mask = 0xf << (GPIO_MODE_ONE_CONTROL_BITS * j);
                uint32_t mode_current = ept_gpio_base->GPIO_MODE[i].RW & pin_mask;
                uint32_t mode_update  = mode_temp[i] & pin_mask;

                if (mode_current != mode_update)
                    reg_mask[i] |= pin_mask;
            }
        }
    }

    for (i = 0; i < GPIO_MODE_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_MODE[i].CLR = reg_mask[i];
        ept_gpio_base->GPIO_MODE[i].SET = mode_temp[i];
    }

#endif
}



/**
  * @brief  write the joint data about GPIO direction configuration to GPIO direction register one by one
  * @param  None
  * @retval None
  */
void gpio_dir_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_DIR_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_DIR_REG_MAX_NUM
    uint32_t dir_temp[GPIO_DIR_REG_MAX_NUM] = { GPIO_DIR_ALL_VALUE };

    for (i = 0; i < GPIO_DIR_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;
        for (j = 0; j < GPIO_DIR_ONE_REG_CONTROL_NUM; j++) {
            temp = j;

            if ((1 << (temp % 32)) &  GPIO_REG_PIN_MASK[temp / 32])
                reg_mask[i] |= 1 << (GPIO_DIR_ONE_CONTROL_BITS * j);
        }
    }

    for (i = 0; i < GPIO_DIR_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_DIR[i].CLR = reg_mask[i];
        ept_gpio_base->GPIO_DIR[i].SET = dir_temp[i];
    }

#endif
}


/**
  * @brief  write the joint data about GPIO output data to GPIO output data register one by one
  * @param  None
  * @retval None
  */
void gpio_output_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_DIR_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_OUTPUT_LEVEL_REG_MAX_NUM
    uint32_t out_temp[GPIO_OUTPUT_LEVEL_REG_MAX_NUM] = { GPIO_OUTPUT_LEVEL_ALL_VALUE };

    for (i = 0; i < GPIO_OUTPUT_LEVEL_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;

        for (j = 0; j < GPIO_OUTPUT_LEVEL_ONE_REG_CONTROL_NUM; j++) {
            temp = j;

            if ((1 << (temp % 32)) &  GPIO_REG_PIN_MASK[temp / 32])
                reg_mask[i] |= 1 << (GPIO_OUTPUT_LEVEL_ONE_CONTROL_BITS * j);
        }
    }

    for (i = 0; i < GPIO_OUTPUT_LEVEL_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_DOUT[i].CLR = reg_mask[i];
        ept_gpio_base->GPIO_DOUT[i].SET = out_temp[i];
    }

#endif
}


/**
  * @brief  write the joint data about GPIO pull configuration about PUPD to GPIO pupd register one by one
  * @param  None
  * @retval None
  */
void gpio_pupd_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_PUPD_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t pupd_temp[GPIO_PUPD_REG_MAX_NUM] = { GPIO_PUPD_ALL_VALUE };

    for (i = 0; i < GPIO_PUPD_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;
        for (j = 0; j < GPIO_PUPD_ONE_REG_CONTROL_NUM; j++) {
            temp = j;

            if ((1 << (temp % 32)) &  GPIO_REG_PIN_MASK[temp / 32])
                reg_mask[i] |= 1 << (GPIO_PUPD_ONE_CONTROL_BITS * j);
        }
    }

    for (i = 0; i < GPIO_PUPD_REG_MAX_NUM; i++) {
        ept_gpio_cfg0->GPIO_PUPD[i].CLR = reg_mask[i];
        ept_gpio_cfg0->GPIO_PUPD[i].SET = pupd_temp[i];
    }

#endif
}


/**
  * @brief  write the joint data about GPIO pull configuration about R0 to GPIO R0 register one by one
  * @param  None
  * @retval None
  */
void gpio_r0_r1_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_R0R1_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t r0_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R0_ALL_VALUE };
    uint32_t r1_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R1_ALL_VALUE };

    for (i = 0; i < GPIO_R0R1_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;

        for (j = 0; j < GPIO_R0R1_ONE_REG_CONTROL_NUM; j++) {
            temp = j;

            if ((1 << (temp % 32)) &  GPIO_REG_PIN_MASK[temp / 32])
                reg_mask[i] |= 1 << (GPIO_R0_ONE_CONTROL_BITS * j);
        }
    }

    for (i = 0; i < GPIO_R0R1_REG_MAX_NUM; i++) {
        ept_gpio_cfg0->GPIO_R0[i].CLR = reg_mask[i];
        ept_gpio_cfg0->GPIO_R0[i].SET = r0_temp[i];
        ept_gpio_cfg0->GPIO_R1[i].CLR = reg_mask[i];
        ept_gpio_cfg0->GPIO_R1[i].SET = r1_temp[i];
    }

#endif
}

/**
  * @brief  Main program to make the configuration of EPT to take effect
  * @param  None
  * @retval None
  */

void bsp_ept_gpio_setting_init(void)
{
    gpio_mode_init();
    gpio_dir_init();
    gpio_pupd_init();
    gpio_r0_r1_init();
    gpio_output_init();
}

